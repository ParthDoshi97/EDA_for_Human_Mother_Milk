Qtrap_filterd_data$NewClass <- factor(Qtrap_filterd_data$NewClass)
# Initialize an empty data frame to store the results
levene_results <- data.frame(Variable = character(0), F_Value = numeric(0), P_Value = numeric(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
formula <- as.formula(paste(vars, "~", categorical_var))
var_test <- leveneTest(formula, data = Qtrap_filterd_data)
levene_results <- rbind(levene_results, data.frame(Variable = vars, F_Value = var_test$`F value`, P_Value = var_test$`Pr(>F)`, Significant = ifelse(var_test$`Pr(>F)` < 0.05, "**", "-")))
}
levene_results
library(ggstatsplot)
library(rlang)
StatBoxplot <- function(y) {
y_sym <- sym(y)
plot <- ggbetweenstats(
data = Qtrap_filterd_data_scaled,
x = NewClass,
y = !!y_sym,
type = "nonparametric",
plot.type = "box",
pairwise.comparisons = TRUE,
pairwise.display = "all",
centrality.plotting = FALSE,
bf.message = FALSE,
ylab = y
)
return(plot)
}
StatBoxplot("3-MeHis")
# Perform Kruskal-Wallis test for each variable
# Initialize an empty data frame to store the Kruskal-Wallis results
kruskal_results <- data.frame(Variable = character(0), H_Statistic = numeric(0), P_Value = numeric(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
formula <- as.formula(paste(vars, "~", categorical_var))
kruskal_model <- kruskal.test(formula, data = Qtrap_filterd_data_Scaled)
# Append the results to the data frame
kruskal_results <- rbind(kruskal_results, data.frame(Variable = vars, H_Statistic = kruskal_model$statistic, P_Value = kruskal_model$p.value, Significant = ifelse(kruskal_model$p.value < 0.05, "**", "-")))
}
# Perform Kruskal-Wallis test for each variable
# Initialize an empty data frame to store the Kruskal-Wallis results
kruskal_results <- data.frame(Variable = character(0), H_Statistic = numeric(0), P_Value = numeric(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
formula <- as.formula(paste(vars, "~", categorical_var))
kruskal_model <- kruskal.test(formula, data = Qtrap_filterd_data)
# Append the results to the data frame
kruskal_results <- rbind(kruskal_results, data.frame(Variable = vars, H_Statistic = kruskal_model$statistic, P_Value = kruskal_model$p.value, Significant = ifelse(kruskal_model$p.value < 0.05, "**", "-")))
}
print(kruskal_results)
# Perform pairwise dunn test and display summary for each model
for (var in continuous_vars) {
formula <- as.formula(paste(var, "~", categorical_var))
pairwise_test <- dunn_test(formula, data = Qtrap_filterd_data_, p.adjust.method = "bonferroni")
cat("Variable:", var)
print(pairwise_test)
cat("/n")
}
# Calculate p-values for each correlation coefficient
p.mat <- cor_pmat(Qtrap_filterd_data_scaled[2:39], method = "pearson")
# calculate correlation matrix
correlationMatrix <- cor(Qtrap_filterd_data_scaled[2:39])
# summarize the correlation matrix
#print(correlationMatrix)
ggcorrplot(
correlationMatrix,
hc.order = TRUE,   # Hierarchical clustering for reordering variables
type = "lower",    # Show only the lower triangle of the correlation matrix
lab = FALSE        # Show labels for variables
)
library(rstatix)
# Define the Continuous Variables and Categorical Variable
continuous_vars <- colnames(Qtrap_filterd_data_scaled[2:39])
categorical_var <- "NewClass"
continuous_vars
# Initialize an empty data frame to store the results
shapiro_results <- data.frame(Variable = character(0), P_Value = numeric(0), Significant = character(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
data_vector <- Qtrap_filterd_data_scaled[[vars]]
shapiro_result <- shapiro.test(data_vector)
# Append the results to the data frame
shapiro_results <- rbind(shapiro_results, data.frame(Variable = vars, P_Value = shapiro_result$p.value, Significant = ifelse(shapiro_result$p.value < 0.05, "**", ".")))
}
# Print the results as a table
print(shapiro_results)
# perform levene's test to see if all group has equal variance
# Update the levels of the New Class variable
Qtrap_filterd_data_scaled$NewClass <- factor(Qtrap_filterd_data_scaled$NewClass)
# Initialize an empty data frame to store the results
levene_results <- data.frame(Variable = character(0), F_Value = numeric(0), P_Value = numeric(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
formula <- as.formula(paste(vars, "~", categorical_var))
var_test <- leveneTest(formula, data = Qtrap_filterd_data_scaled)
levene_results <- rbind(levene_results, data.frame(Variable = vars, F_Value = var_test$`F value`, P_Value = var_test$`Pr(>F)`, Significant = ifelse(var_test$`Pr(>F)` < 0.05, "**", "-")))
}
levene_results
# Perform Kruskal-Wallis test for each variable
# Initialize an empty data frame to store the Kruskal-Wallis results
kruskal_results <- data.frame(Variable = character(0), H_Statistic = numeric(0), P_Value = numeric(0), stringsAsFactors = FALSE)
# Loop through the continuous variables
for (vars in continuous_vars) {
formula <- as.formula(paste(vars, "~", categorical_var))
kruskal_model <- kruskal.test(formula, data = Qtrap_filterd_data_scaled)
# Append the results to the data frame
kruskal_results <- rbind(kruskal_results, data.frame(Variable = vars, H_Statistic = kruskal_model$statistic, P_Value = kruskal_model$p.value, Significant = ifelse(kruskal_model$p.value < 0.05, "**", "-")))
}
print(kruskal_results)
# Perform pairwise dunn test and display summary for each model
for (var in continuous_vars) {
formula <- as.formula(paste(var, "~", categorical_var))
pairwise_test <- dunn_test(formula, data = Qtrap_filterd_data_scaled, p.adjust.method = "bonferroni")
cat("Variable:", var)
print(pairwise_test)
cat("/n")
}
library(ggstatsplot)
library(rlang)
StatBoxplot <- function(y) {
y_sym <- sym(y)
plot <- ggbetweenstats(
data = Qtrap_filterd_data_scaled,
x = NewClass,
y = !!y_sym,
type = "nonparametric",
plot.type = "box",
pairwise.comparisons = TRUE,
pairwise.display = "all",
centrality.plotting = FALSE,
bf.message = FALSE,
ylab = y
)
return(plot)
}
StatBoxplot <- function(y) {
y_sym <- sym(y)
plot <- ggbetweenstats(
data = Qtrap_filterd_data_scaled,
x = NewClass,
y = !!y_sym,
type = "nonparametric",
plot.type = "box",
pairwise.comparisons = TRUE,
pairwise.display = "all",
centrality.plotting = FALSE,
bf.message = FALSE,
ylab = y
)
return(plot)
}
library(ggstatsplot)
library(rlang)
StatBoxplot <- function(y) {
y_sym <- sym(y)
plot <- ggbetweenstats(
data = Qtrap_filterd_data_scaled,
x = NewClass,
y = !!y_sym,
type = "nonparametric",
plot.type = "box",
pairwise.comparisons = TRUE,
pairwise.display = "all",
centrality.plotting = FALSE,
bf.message = FALSE,
ylab = y
)
return(plot)
}
for(var in continuous_vars){
StatBoxplot(var)
}
View(StatBoxplot)
# Perform Regression for each continuous variable
for (Vars in continuous.vars) {
formula <- as.formula(paste(Vars, "~", categorial.var))
LM.model <-lm(formula, data = Qtrap_filterd_data_scaled)
cat("Variable:",Vars, "/n")
print(summary(LM.model))
cat("/n")
}
# Perform Regression for each continuous variable
for (Vars in continuous_vars) {
formula <- as.formula(paste(Vars, "~", categorial_var))
LM.model <-lm(formula, data = Qtrap_filterd_data_scaled)
cat("Variable:",Vars, "/n")
print(summary(LM.model))
cat("/n")
}
# Perform Regression for each continuous variable
for (Vars in continuous_vars) {
formula <- as.formula(paste(Vars, "~", categorical_var))
LM.model <-lm(formula, data = Qtrap_filterd_data_scaled)
cat("Variable:",Vars, "/n")
print(summary(LM.model))
cat("/n")
}
View(Qtrap_filterd_data_scaled.subset.B)
View(Qtrap_filterd_data_scaled)
set.seed(2000)
# Define the control for recursive feature elimination (RFE) using random forest
control <- rfeControl(functions = rfFuncs, method = "cv", number = 10)
# Run the RFE algorithm
results <- rfe(Qtrap_filterd_data_scaled[, 3:39], Qtrap_filterd_data_scaled[, 57], sizes = c(1:8), rfeControl = control)
# Summarize the results
print(results)
# List the chosen features selected by RFE
predictors(results)
library(Boruta)
# Decide if a variable is important or not using Boruta
boruta_output <- Boruta(NewClass ~ ., data=na.omit(Qtrap_filterd_data_scaled), doTrace=2)  # perform Boruta search
boruta_signif <- names(boruta_output$finalDecision[boruta_output$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
plot(boruta_output, cex.axis=.7, las=2, xlab="", main="Variable Importance")  # plot variable
Qtrap_filterd_data_scaled_longA <- gather(Qtrap_filterd_data_scaled[2:25])
View(Qtrap_filterd_data_scaled_longA)
Qtrap_filterd_data_scaled.longA <- gather(Qtrap_filterd_data_scaled[2:25])
Qtrap_filterd_data_scaled.longB <- gather(Qtrap_filterd_data_scaled[25:39])
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotA <- ggplot(Qtrap_filterd_data_scaled.longA, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotA)
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotB <- ggplot(Qtrap_filterd_data_scaled.longB, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotB)
Qtrap_filterd_data_scaled.subset.A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
View(Qtrap_filterd_data_scaled.subset.A)
Qtrap_filterd_data_scaled.subset.B <- Qtrap_filterd_data_scaled %>%
select(-c(2:25))
View(Qtrap_filterd_data_scaled.subset.B)
Qtrap_filterd_data_scaled.subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
View(Qtrap_filterd_data_scaled.subset.A)
Qtrap_filterd_data_scaled_subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
knitr::opts_chunk$set(dev = "png",
dpi = 300,
echo = TRUE,
cache = TRUE)
# install required library
library(devtools)
#devtools::install_github("sfirke/janitor")
# load Required libraries
library(tidyverse) # meta package of all tidyverse packages
library(janitor) #
library(ggplot2)
library(corrplot)
library(ggcorrplot)
library(caret)
library(FactoMineR)
library(ggfortify)
library(factoextra)
library(reshape2)
library(moments)
library(skimr)
library(car)
# Set Working Directory
setwd("C:/Users/Parth Doshi/Dropbox/Nutrishield_Study_II_Project (ParthD thesis)/R-script/EDA_for_Human_Mother_Milk")
#load Data
QTrap_Semiquant_Data <- read.csv("C:/Users/Parth Doshi/Dropbox/Nutrishield_Study_II_Project (ParthD thesis)/NSII_Corrected_and_Clean_Data/NSII_Qtrap_Semiquant_Urine.csv",sep = ",")
str(QTrap_Semiquant_Data)
#  Cleaning the data sets
QTrap_Semiquant_Data <- QTrap_Semiquant_Data %>%
select(-X,-NewClass) %>% # Select columns with names containing "IU" or "MU"
as.data.frame()
# Print summary of QTrap Semiquant Data
summary(QTrap_Semiquant_Data)
# Calculate the percentage of missing values for each column
missing.percent <- colSums(QTrap_Semiquant_Data == 0 | QTrap_Semiquant_Data == 0.0) / nrow(QTrap_Semiquant_Data) * 100
# Print the percentage of missing values for each column
print(missing.percent)
# Get the names of columns with missing values exceeding 50%
missing.variables <- names(missing.percent[missing.percent > 50])
# Print the names of columns with missing values exceeding 50%
print(missing.variables)
# Assuming your dataset is named 'data'
Qtrap_filterd_data <- QTrap_Semiquant_Data[, !names(QTrap_Semiquant_Data) %in% missing.variables]
skimmed <- skim_to_wide(Qtrap_filterd_data)
skimmed
skewness(Qtrap_filterd_data[3:39])
#scaling Of Data
# using caret lib to preprocess data
Normalization <- preProcess(Qtrap_filterd_data, method = "BoxCox",na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_normal <- predict(Normalization,Qtrap_filterd_data)
#scaling Of Data
# using caret lib to preprocess data
AutoScaling <- preProcess(Qtrap_filterd_data_normal, method = c("scale","center"),na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_scaled <- predict(AutoScaling,Qtrap_filterd_data_normal)
# Replacing the value Infinite value  with 0
#for (col in names(Qtrap_filterd_data_scaled)) {
#  Qtrap_filterd_data_scaled[[col]][!is.finite(Qtrap_filterd_data_scaled[[col]])] <- 0
#}
#Qtrap_filterd_data_scaled <- cbind(QTrap_Semiquant_Data[1:2],Qtrap_filterd_data_scaled)
# Calculate the skewness of the scaled data
skewness(Qtrap_filterd_data_scaled[3:39])
# Summary statistics
skimmed_normal <-skim(Qtrap_filterd_data_scaled)
skimmed_normal
# Calculate the skewness of the scaled data
skewness(Qtrap_filterd_data_scaled[3:39])
#scaling Of Data
# using caret lib to preprocess data
Normalization <- preProcess(Qtrap_filterd_data, method = "YeoJohnson",na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_normal <- predict(Normalization,Qtrap_filterd_data)
#scaling Of Data
# using caret lib to preprocess data
AutoScaling <- preProcess(Qtrap_filterd_data_normal, method = c("scale","center"),na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_scaled <- predict(AutoScaling,Qtrap_filterd_data_normal)
# Replacing the value Infinite value  with 0
#for (col in names(Qtrap_filterd_data_scaled)) {
#  Qtrap_filterd_data_scaled[[col]][!is.finite(Qtrap_filterd_data_scaled[[col]])] <- 0
#}
#Qtrap_filterd_data_scaled <- cbind(QTrap_Semiquant_Data[1:2],Qtrap_filterd_data_scaled)
# Calculate the skewness of the scaled data
skewness(Qtrap_filterd_data_scaled[3:39])
# Summary statistics
skimmed_normal <-skim(Qtrap_filterd_data_scaled)
skimmed_normal
Qtrap_filterd_data_scaled.longA <- gather(Qtrap_filterd_data_scaled[2:25])
Qtrap_filterd_data_scaled.longB <- gather(Qtrap_filterd_data_scaled[25:39])
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotA <- ggplot(Qtrap_filterd_data_scaled.longA, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotA)
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotB <- ggplot(Qtrap_filterd_data_scaled.longB, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotB)
Qtrap_filterd_data_scaled.longA <- gather(Qtrap_filterd_data_scaled[2:25])
View(Qtrap_filterd_data_scaled.longA)
Qtrap_filterd_data_scaled.longA <- gather(Qtrap_filterd_data_scaled[2:25])
View(Qtrap_filterd_data_scaled.longA)
View(Qtrap_filterd_data_scaled.longB)
Qtrap_filterd_data_scaled.longA <-gather(Qtrap_filterd_data_scaled[2:24])
View(Qtrap_filterd_data_scaled.longA)
#  Cleaning the data sets
QTrap_Semiquant_Data <- QTrap_Semiquant_Data %>%
select(-X,-Class) %>% # Select columns with names containing "IU" or "MU"
as.data.frame()
# Set Working Directory
setwd("C:/Users/Parth Doshi/Dropbox/Nutrishield_Study_II_Project (ParthD thesis)/R-script/EDA_for_Human_Mother_Milk")
#load Data
QTrap_Semiquant_Data <- read.csv("C:/Users/Parth Doshi/Dropbox/Nutrishield_Study_II_Project (ParthD thesis)/NSII_Corrected_and_Clean_Data/NSII_Qtrap_Semiquant_Urine.csv",sep = ",")
str(QTrap_Semiquant_Data)
#  Cleaning the data sets
QTrap_Semiquant_Data <- QTrap_Semiquant_Data %>%
select(-X,-Class) %>% # Select columns with names containing "IU" or "MU"
as.data.frame()
# Print summary of QTrap Semiquant Data
summary(QTrap_Semiquant_Data)
# Calculate the percentage of missing values for each column
missing.percent <- colSums(QTrap_Semiquant_Data == 0 | QTrap_Semiquant_Data == 0.0) / nrow(QTrap_Semiquant_Data) * 100
# Print the percentage of missing values for each column
print(missing.percent)
# Get the names of columns with missing values exceeding 50%
missing.variables <- names(missing.percent[missing.percent > 50])
# Print the names of columns with missing values exceeding 50%
print(missing.variables)
# Assuming your dataset is named 'data'
Qtrap_filterd_data <- QTrap_Semiquant_Data[, !names(QTrap_Semiquant_Data) %in% missing.variables]
skimmed <- skim_to_wide(Qtrap_filterd_data)
skimmed
skewness(Qtrap_filterd_data[3:39])
#scaling Of Data
# using caret lib to preprocess data
Normalization <- preProcess(Qtrap_filterd_data, method = "YeoJohnson",na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_normal <- predict(Normalization,Qtrap_filterd_data)
#scaling Of Data
# using caret lib to preprocess data
AutoScaling <- preProcess(Qtrap_filterd_data_normal, method = c("scale","center"),na.remove = TRUE )
# standardize the preprocessed data
Qtrap_filterd_data_scaled <- predict(AutoScaling,Qtrap_filterd_data_normal)
# Replacing the value Infinite value  with 0
#for (col in names(Qtrap_filterd_data_scaled)) {
#  Qtrap_filterd_data_scaled[[col]][!is.finite(Qtrap_filterd_data_scaled[[col]])] <- 0
#}
#Qtrap_filterd_data_scaled <- cbind(QTrap_Semiquant_Data[1:2],Qtrap_filterd_data_scaled)
# Calculate the skewness of the scaled data
skewness(Qtrap_filterd_data_scaled[3:39])
# Summary statistics
skimmed_normal <-skim(Qtrap_filterd_data_scaled)
skimmed_normal
Qtrap_filterd_data_scaled_long_A <- gather(Qtrap_filterd_data_scaled[2:24])
Qtrap_filterd_data_scaled_long_B <- gather(Qtrap_filterd_data_scaled[25:39])
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotA <- ggplot(Qtrap_filterd_data_scaled_long_A, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotA)
# box plot after distribution for Subset
Qtrap_filterd_data_scaled.boxplotB <- ggplot(Qtrap_filterd_data_scaled_long_B, aes(x = value, y = key, fill = key))+
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Qtrap filtered data Boxplot",)
print(Qtrap_filterd_data_scaled.boxplotB)
Qtrap_filterd_data_scaled_subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
View(Qtrap_filterd_data_scaled_subset_A)
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled.subset.A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled_subset_A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled_subset_A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled_subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
Qtrap_filterd_data_scaled.subset_B <- Qtrap_filterd_data_scaled %>%
select(-c(2:25))
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled_subset_A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled.subset.B %>%
gather(key = "feature", value = "value", -Sample, -NewClass,-Month, -ID) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled_subset_B <- Qtrap_filterd_data_scaled %>%
select(-c(2:25))
View(Qtrap_filterd_data_scaled_subset_B)
Qtrap_filterd_data_scaled_subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
Qtrap_filterd_data_scaled_subset_B <- Qtrap_filterd_data_scaled %>%
select(-c(2:25))
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled_subset_A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled.subset.B %>%
gather(key = "feature", value = "value", -Sample, -NewClass,-Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled_subset_A <- Qtrap_filterd_data_scaled %>%
select(-c(26:39))
Qtrap_filterd_data_scaled_subset_B <- Qtrap_filterd_data_scaled %>%
select(-c(2:25))
# Box plot of data distribution of each group (Mother , PI , TI)
Qtrap_filterd_data_scaled_subset_A %>%
gather(key = "feature", value = "value", -Sample, -NewClass, -Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
Qtrap_filterd_data_scaled_subset_B %>%
gather(key = "feature", value = "value", -Sample, -NewClass,-Month, -ID, -Type) %>%
ggplot(aes(x = NewClass, y = value, fill = NewClass)) +
geom_boxplot() +
facet_wrap(~ feature, scales = "free") +
labs(x = "Group", y = "Value")
# Principle component Analysis
QTrap_Semiquant_Data.pca <- prcomp(Qtrap_filterd_data_scaled[3:39], scale. = TRUE, center = TRUE)
#Visualization of PCA
fviz_pca_ind(QTrap_Semiquant_Data.pca,
geom = "point",
habillage = Qtrap_filterd_data_scaled$NewClass,
palette = c( "red", "green2","blue"),
addEllipses = TRUE,
ellipse_type = "confidence",
ggtheme = theme_bw(),
title = "PCA plot for Qtrap Semiquant biomarkrs")
#Scree plot
fviz_eig(QTrap_Semiquant_Data.pca,
addlabels = TRUE,
ylim = c(0, 70),
main="Figure 5: Scree Plot  Qtrap Semiquant ")
#Graph for variable
fviz_pca_var(QTrap_Semiquant_Data.pca, col.var = "red")
# Calculate p-values for each correlation coefficient
p.mat <- cor_pmat(Qtrap_filterd_data_scaled[2:39], method = "pearson")
# calculate correlation matrix
correlationMatrix <- cor(Qtrap_filterd_data_scaled[2:39])
# summarize the correlation matrix
#print(correlationMatrix)
ggcorrplot(
correlationMatrix,
hc.order = TRUE,   # Hierarchical clustering for reordering variables
type = "lower",    # Show only the lower triangle of the correlation matrix
lab = FALSE        # Show labels for variables
)
